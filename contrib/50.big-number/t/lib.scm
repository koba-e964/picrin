(define-library (picrin big-number)
  (import (scheme base))
  
  (define (bigint-pow a b)
    (if (bigint-less? b 0)
	(make-bigint 1)
	(bigint-pow-positive a b (make-bigint 1))))
  (define (bigint-pow-positive a b sum)
    (if (bigint-less? b 1)
	sum
	(let ((aa (bigint-mul a a)))
	  (if (bigint-equal? (bigint-rem b 2) 0)
	      (bigint-pow-positive aa (bigint-div b 2) sum)
	      (bigint-pow-positive aa (bigint-div b 2) (bigint-mul sum a))))))
  (define (bigint-pow-mod a b mod)
    (if (bigint-less? b 0)
	(bigint-rem 1 mod)
	(bigint-pow-mod-positive a b (make-bigint 1) mod)))
  (define (bigint-pow-mod-positive a b sum mod)
    (if (bigint-less? b 1)
	sum
	(let ((aa (bigint-mul-mod a a mod)))
	  (if (bigint-equal? (bigint-rem b 2) 0)
	      (bigint-pow-mod-positive aa (bigint-div b 2) sum mod)
	      (bigint-pow-mod-positive aa (bigint-div b 2) (bigint-mul-mod sum a mod) mod)))))
  (define (bigint-prime? prime . cert)
    (if (or (bigint-less? prime 2) (bigint-equal? (bigint-rem prime 2) 0))
	#f
	(if (bigint-less? prime 8)
	    #t
	    ;; Find k, d s.t. prime = 2^k * d + 1
	    (let loop ((k 0) (d (bigint-sub prime 1)))
	      (if (bigint-equal? (bigint-rem d 2) 0)
		  (loop (+ k 1) (bigint-div d 2))
		  ;; Found
		  (bigint-prime?-trial prime k d))))))
  (define (bigint-prime?-trial prime k d)
    (let loop ((i 0))
      (if (< i 20)
	  (let ((a (bigint-rand prime)))
	    (if (bigint-prime?-once prime k d a)
		(loop (+ i 1))
		#f))
	    #t)))
  (define (bigint-prime?-once prime k d a)
    (let loop ((i 0) (c (bigint-pow-mod a d prime)))
      (if (>= i k)
	  (bigint-equal? 1 c)
	  (let ((cc (bigint-pow-mod c c prime)))
	    (if (bigint-equal? cc 1)
		(or (bigint-equal? c 1) (bigint-equal? c (bigint-sub prime 1)))
		(loop (+ i 1) cc))))))
  (export bigint-pow bigint-pow-mod bigint-prime?))
