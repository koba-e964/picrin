(define-library (picrin big-number)
  (import (scheme base))
  
  (define (bigint-pow a b)
    (if (bigint-less? b 0)
	(make-bigint 1)
	(bigint-pow-positive a b)))
  (define (bigint-pow-positive a b)
    (let ((len (bigint-bit-length b)))
      (let loop ((i 0) (sum (make-bigint 1)) (cur a))
	(if (< i len)
	    (if (bigint-bit-test b i)
		(loop (+ i 1) (bigint-mul sum cur) (bigint-mul cur cur))
		(loop (+ i 1) sum (bigint-mul cur cur)))
	    sum))))
  (define (bigint-pow-mod a b mod)
    (if (bigint-less? b 0)
	(bigint-rem 1 mod)
	(bigint-pow-mod-positive a b mod)))
  (define (bigint-pow-mod-positive a b mod)
    (let ((len (bigint-bit-length b)))
      (let loop ((i 0) (sum (make-bigint 1)) (cur a))
	(if (< i len)
	    (if (bigint-bit-test b i)
		(loop (+ i 1) (bigint-mul-mod sum cur mod) (bigint-mul-mod cur cur mod))
		(loop (+ i 1) sum (bigint-mul-mod cur cur mod)))
	    sum))))
  (define (bigint-prime? prime . cert)
    (if (or (bigint-less? prime 2) (bigint-equal? (bigint-rem prime 2) 0))
	#f
	(if (bigint-less? prime 8)
	    #t
	    ;; Find k, d s.t. prime = 2^k * d + 1
	    (let loop ((k 0) (d (bigint-sub prime 1)))
	      (if (bigint-equal? (bigint-rem d 2) 0)
		  (loop (+ k 1) (bigint-div d 2))
		  ;; Found
		  (bigint-prime?-trial prime k d))))))
  (define (bigint-prime?-trial prime k d)
    (let loop ((i 0))
      (if (< i 20)
	  (let ((a (bigint-rand prime)))
	    (if (bigint-prime?-once prime k d a)
		(loop (+ i 1))
		#f))
	    #t)))
  (define (bigint-prime?-once prime k d a)
    (let loop ((i 0) (c (bigint-pow-mod a d prime)))
      (if (>= i k)
	  (bigint-equal? 1 c)
	  (let ((cc (bigint-pow-mod c c prime)))
	    (if (bigint-equal? cc 1)
		(or (bigint-equal? c 1) (bigint-equal? c (bigint-sub prime 1)))
		(loop (+ i 1) cc))))))
  (export bigint-pow bigint-pow-mod bigint-prime?))
